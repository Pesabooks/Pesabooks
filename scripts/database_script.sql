-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 
BEGIN;
CREATE TABLE IF NOT EXISTS public.tokens
(
    address character varying COLLATE pg_catalog."default" NOT NULL,
    symbol character varying COLLATE pg_catalog."default" NOT NULL,
    name character varying COLLATE pg_catalog."default" NOT NULL,
    image character varying COLLATE pg_catalog."default" NOT NULL,
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    active boolean NOT NULL,
    decimals smallint,
    chain_id bigint,
    CONSTRAINT tokens_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.tokens
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.tokens
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.tokens TO anon;

GRANT ALL ON TABLE public.tokens TO authenticated;

GRANT ALL ON TABLE public.tokens TO postgres;

GRANT ALL ON TABLE public.tokens TO service_role;

GRANT ALL ON TABLE public.tokens TO supabase_admin;

CREATE TABLE IF NOT EXISTS public.pools
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    token_id bigint NOT NULL,
    created_by uuid DEFAULT auth.uid(),
    created_by_id uuid DEFAULT auth.uid(),
    chain_id integer NOT NULL DEFAULT 80001,
    active boolean NOT NULL DEFAULT true,
    contract_address character varying COLLATE pg_catalog."default",
    CONSTRAINT pools_pkey PRIMARY KEY (id),
    CONSTRAINT pools_created_by_fkey FOREIGN KEY (created_by)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT pools_created_by_id_fkey FOREIGN KEY (created_by_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT pools_token_id_fkey FOREIGN KEY (token_id)
        REFERENCES public.tokens (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.pools
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.pools
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.pools TO anon;

GRANT ALL ON TABLE public.pools TO authenticated;

GRANT ALL ON TABLE public.pools TO postgres;

GRANT ALL ON TABLE public.pools TO service_role;

GRANT ALL ON TABLE public.pools TO supabase_admin;

CREATE TABLE IF NOT EXISTS public.profiles
(
    id uuid NOT NULL,
    name character varying COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    last_pool_id bigint,
    email character varying COLLATE pg_catalog."default",
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT profiles_last_pool_id_fkey FOREIGN KEY (last_pool_id)
        REFERENCES public.pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.profiles
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.profiles
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profiles TO anon;

GRANT ALL ON TABLE public.profiles TO authenticated;

GRANT ALL ON TABLE public.profiles TO postgres;

GRANT ALL ON TABLE public.profiles TO service_role;

GRANT ALL ON TABLE public.profiles TO supabase_admin;


CREATE TABLE IF NOT EXISTS public.accounts
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    pool_id bigint NOT NULL,
    name character varying COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    is_default boolean NOT NULL DEFAULT false,
    contract_address character varying COLLATE pg_catalog."default" NOT NULL,
    created_by_id uuid DEFAULT auth.uid(),
    CONSTRAINT accounts_pkey PRIMARY KEY (id),
    CONSTRAINT accounts_contract_address_key UNIQUE (contract_address),
    CONSTRAINT accounts_created_by_id_fkey FOREIGN KEY (created_by_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT accounts_pool_id_fkey FOREIGN KEY (pool_id)
        REFERENCES public.pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.accounts
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.accounts
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.accounts TO anon;

GRANT ALL ON TABLE public.accounts TO authenticated;

GRANT ALL ON TABLE public.accounts TO postgres;

GRANT ALL ON TABLE public.accounts TO service_role;

GRANT ALL ON TABLE public.accounts TO supabase_admin;

CREATE TABLE IF NOT EXISTS public.categories
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default",
    pool_id bigint NOT NULL,
    type character varying COLLATE pg_catalog."default",
    CONSTRAINT categories_pkey PRIMARY KEY (id),
    CONSTRAINT categories_pool_id_fkey FOREIGN KEY (pool_id)
        REFERENCES public.pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.categories
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.categories
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.categories TO anon;

GRANT ALL ON TABLE public.categories TO authenticated;

GRANT ALL ON TABLE public.categories TO postgres;

GRANT ALL ON TABLE public.categories TO service_role;

GRANT ALL ON TABLE public.categories TO supabase_admin;

CREATE TABLE IF NOT EXISTS public.members
(
    user_id uuid NOT NULL,
    pool_id bigint NOT NULL,
    role character varying COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    is_owner boolean NOT NULL DEFAULT false,
    active boolean NOT NULL DEFAULT true,
    CONSTRAINT user_pool_pkey PRIMARY KEY (user_id, pool_id),
    CONSTRAINT members_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.profiles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT user_pool_pool_id_fkey FOREIGN KEY (pool_id)
        REFERENCES public.pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.members
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.members
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.members TO anon;

GRANT ALL ON TABLE public.members TO authenticated;

GRANT ALL ON TABLE public.members TO postgres;

GRANT ALL ON TABLE public.members TO service_role;

GRANT ALL ON TABLE public.members TO supabase_admin;

CREATE TABLE IF NOT EXISTS public.transactions
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    "from" character varying COLLATE pg_catalog."default",
    "to" character varying COLLATE pg_catalog."default",
    user_id uuid,
    amount double precision NOT NULL,
    memo text COLLATE pg_catalog."default",
    hash character varying COLLATE pg_catalog."default",
    type character varying COLLATE pg_catalog."default" NOT NULL,
    status smallint NOT NULL,
    pool_id bigint NOT NULL,
    "timestamp" bigint,
    transfer_from character varying COLLATE pg_catalog."default",
    transfer_to character varying COLLATE pg_catalog."default",
    category_id bigint,
    created_by_id uuid DEFAULT auth.uid(),
    CONSTRAINT transactions_pkey PRIMARY KEY (id),
    CONSTRAINT unique_transaction_hash UNIQUE (hash),
    CONSTRAINT transactions_category_id_fkey FOREIGN KEY (category_id)
        REFERENCES public.categories (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT transactions_created_by_id_fkey FOREIGN KEY (created_by_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT transactions_pool_id_fkey FOREIGN KEY (pool_id)
        REFERENCES public.pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT transactions_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.transactions
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.transactions
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.transactions TO anon;

GRANT ALL ON TABLE public.transactions TO authenticated;

GRANT ALL ON TABLE public.transactions TO postgres;

GRANT ALL ON TABLE public.transactions TO service_role;

GRANT ALL ON TABLE public.transactions TO supabase_admin;


CREATE OR REPLACE FUNCTION public.create_pool(
	name character varying,
	description text,
	token_id integer,
	pool_address character varying,
	account_address character varying)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$


declare 
  pool_id bigint;
begin
  insert into pools(name, description, token_id, contract_address)
  values (create_pool.name, create_pool.description, create_pool.token_id, pool_address)
  returning id into pool_id;

  insert into members
  (user_id, pool_id, "role", is_owner )
  values
  (auth.uid(), pool_id, 'admin', true );

  -- Create default accounts
  insert into accounts (pool_id, name, description, is_default, contract_address)
  values (pool_id, 'Primary Account', 'Default account', true, create_pool.account_address );

  -- update use profile
  update profiles set last_pool_id=pool_id where id = auth.uid();

  -- Create default categories
  insert into categories
  (name, pool_id )
  values
  ('Regular contribution', pool_id), 
  ('Volontary savings', pool_id), 
  ('Pool withdrawal', pool_id), 
  ('Payments & Interests', pool_id),  
  ('Penalties and Fees', pool_id) ,
  ('Long term loan', pool_id),
  ('Short term loan', pool_id);

  return pool_id;
end;

$BODY$;

ALTER FUNCTION public.create_pool(character varying, text, integer, character varying, character varying)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.create_pool(character varying, text, integer, character varying, character varying) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.create_pool(character varying, text, integer, character varying, character varying) TO anon;

GRANT EXECUTE ON FUNCTION public.create_pool(character varying, text, integer, character varying, character varying) TO authenticated;

GRANT EXECUTE ON FUNCTION public.create_pool(character varying, text, integer, character varying, character varying) TO postgres;

GRANT EXECUTE ON FUNCTION public.create_pool(character varying, text, integer, character varying, character varying) TO service_role;

GRANT EXECUTE ON FUNCTION public.create_pool(character varying, text, integer, character varying, character varying) TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_address_lookup(
	pool_id integer)
    RETURNS TABLE(address character varying, name character varying, type text, id text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

begin
  return query
  select distinct t.from AS address, p.name as "name", 'user'  as "type", p.id::text as "id"
  from transactions t
  left join profiles p on p.id = t.user_id
  where t.type = 'deposit' and t.pool_id = get_address_lookup.pool_id
  
  union

  select a.contract_address as address, a.name as name, 'account' as "type", a.id::text as "id"
  from accounts a
  where a.pool_id=get_address_lookup.pool_id;

end;

$BODY$;

ALTER FUNCTION public.get_address_lookup(integer)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_address_lookup(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_address_lookup(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_address_lookup(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_address_lookup(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_address_lookup(integer) TO service_role;

GRANT EXECUTE ON FUNCTION public.get_address_lookup(integer) TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_balance_per_month(
	pool_id integer)
    RETURNS TABLE(month date, balance double precision) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

begin
  return query
  with balances as (
    select
      date_trunc('month', created_at) as "date",
      SUM (CASE
                WHEN type = 'deposit'  THEN amount
                WHEN type = 'withdrawal'  THEN -amount
                ELSE 0
            END) AS total
    from transactions t
    where t.pool_id = get_balance_per_month.pool_id
    group by 1
  )

  select
   "date"::date as "month",
    sum(b.total) over (order by "date" asc rows between unbounded preceding and current row) as "balance"
  from balances b;

end;
$BODY$;

ALTER FUNCTION public.get_balance_per_month(integer)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_balance_per_month(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_balance_per_month(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_balance_per_month(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_balance_per_month(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_balance_per_month(integer) TO service_role;

GRANT EXECUTE ON FUNCTION public.get_balance_per_month(integer) TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_pool_users(
	pool_id integer)
    RETURNS SETOF profiles 
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  
  select p.*
  from  profiles p
  join members up on up.user_id = p.id
  where up.pool_id = get_pool_users.pool_id
  
$BODY$;

ALTER FUNCTION public.get_pool_users(integer)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_pool_users(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_pool_users(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_pool_users(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_pool_users(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_pool_users(integer) TO service_role;

GRANT EXECUTE ON FUNCTION public.get_pool_users(integer) TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_pools_for_authenticated_user(
	)
    RETURNS SETOF bigint 
    LANGUAGE 'sql'
    COST 100
    STABLE SECURITY DEFINER PARALLEL UNSAFE
    ROWS 1000

    SET search_path=public
AS $BODY$

    select pool_id
    from members
    where user_id = auth.uid()
$BODY$;

ALTER FUNCTION public.get_pools_for_authenticated_user()
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_pools_for_authenticated_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_pools_for_authenticated_user() TO anon;

GRANT EXECUTE ON FUNCTION public.get_pools_for_authenticated_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_pools_for_authenticated_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.get_pools_for_authenticated_user() TO service_role;

GRANT EXECUTE ON FUNCTION public.get_pools_for_authenticated_user() TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_total_per_category(
	pool_id integer)
    RETURNS TABLE(name character varying, deposit double precision, withdrawal double precision) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

begin
  return query
    select c.name ,
        SUM (CASE
            WHEN t.type = 'deposit'  THEN amount
            ELSE 0
        END) AS deposit,
        SUM (CASE
            WHEN t.type = 'withdrawal'  THEN amount
            ELSE 0
        END) AS withdrawal
    from transactions t
    left join categories c on t.category_id=c.id
    where t.pool_id = get_total_per_category.pool_id
    group by category_id, c.name;

end;

$BODY$;

ALTER FUNCTION public.get_total_per_category(integer)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_total_per_category(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_total_per_category(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_total_per_category(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_total_per_category(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_total_per_category(integer) TO service_role;

GRANT EXECUTE ON FUNCTION public.get_total_per_category(integer) TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_transactions_per_month(
	pool_id integer)
    RETURNS TABLE(month date, deposit double precision, withdrawal double precision) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

begin
  return query
    select date_trunc('month',created_at)::date as "month" ,
        SUM (CASE
            WHEN type = 'deposit'  THEN amount
            ELSE 0
        END) AS deposit,
        SUM (CASE
            WHEN type = 'withdrawal'  THEN amount
            ELSE 0
        END) AS withdrawal
    from transactions t
    where t.pool_id = get_transactions_per_month.pool_id
    group by date_trunc('month',created_at)::date
    order by date_trunc('month',created_at)::date;

end;

$BODY$;

ALTER FUNCTION public.get_transactions_per_month(integer)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_transactions_per_month(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_transactions_per_month(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_transactions_per_month(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_transactions_per_month(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_transactions_per_month(integer) TO service_role;

GRANT EXECUTE ON FUNCTION public.get_transactions_per_month(integer) TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_transactions_stats(
	pool_id integer)
    RETURNS TABLE(count bigint, deposit double precision, withdrawal double precision) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

begin
  return query
    select count(*) ,
        SUM (CASE
            WHEN type = 'deposit'  THEN amount
            ELSE 0
        END) AS deposit,
        SUM (CASE
            WHEN type = 'withdrawal'  THEN amount
            ELSE 0
        END) AS withdrawal
    from transactions t
    where t.pool_id = get_transactions_stats.pool_id;

end;

$BODY$;

ALTER FUNCTION public.get_transactions_stats(integer)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_transactions_stats(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_transactions_stats(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_transactions_stats(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_transactions_stats(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_transactions_stats(integer) TO service_role;

GRANT EXECUTE ON FUNCTION public.get_transactions_stats(integer) TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_user_last_address(
	pool_id integer)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  
  select t.from
  from  transactions t
  where t.type = 'deposit' and t.pool_id = get_user_last_address.pool_id
  ORDER BY created_at 
  DESC LIMIT 1;
$BODY$;

ALTER FUNCTION public.get_user_last_address(integer)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer) TO service_role;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer) TO supabase_admin;


CREATE OR REPLACE FUNCTION public.get_user_last_address(
	pool_id integer,
	user_id uuid)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  
  select t.from
  from  transactions t
  where t.type = 'deposit' and t.pool_id = get_user_last_address.pool_id and t.user_id = get_user_last_address.user_id
  ORDER BY created_at 
  DESC LIMIT 1;
$BODY$;

ALTER FUNCTION public.get_user_last_address(integer, uuid)
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer, uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer, uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer, uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer, uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer, uuid) TO service_role;

GRANT EXECUTE ON FUNCTION public.get_user_last_address(integer, uuid) TO supabase_admin;

CREATE SEQUENCE IF NOT EXISTS public.accounts_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.accounts_id_seq
    OWNER TO supabase_admin;

GRANT ALL ON SEQUENCE public.accounts_id_seq TO anon;

GRANT ALL ON SEQUENCE public.accounts_id_seq TO authenticated;

GRANT ALL ON SEQUENCE public.accounts_id_seq TO postgres;

GRANT ALL ON SEQUENCE public.accounts_id_seq TO service_role;

GRANT ALL ON SEQUENCE public.accounts_id_seq TO supabase_admin;
CREATE SEQUENCE IF NOT EXISTS public.categories_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.categories_id_seq
    OWNER TO supabase_admin;

GRANT ALL ON SEQUENCE public.categories_id_seq TO anon;

GRANT ALL ON SEQUENCE public.categories_id_seq TO authenticated;

GRANT ALL ON SEQUENCE public.categories_id_seq TO postgres;

GRANT ALL ON SEQUENCE public.categories_id_seq TO service_role;

GRANT ALL ON SEQUENCE public.categories_id_seq TO supabase_admin;
CREATE SEQUENCE IF NOT EXISTS public.pools_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.pools_id_seq
    OWNER TO supabase_admin;

GRANT ALL ON SEQUENCE public.pools_id_seq TO anon;

GRANT ALL ON SEQUENCE public.pools_id_seq TO authenticated;

GRANT ALL ON SEQUENCE public.pools_id_seq TO postgres;

GRANT ALL ON SEQUENCE public.pools_id_seq TO service_role;

GRANT ALL ON SEQUENCE public.pools_id_seq TO supabase_admin;
CREATE SEQUENCE IF NOT EXISTS public.tokens_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.tokens_id_seq
    OWNER TO supabase_admin;

GRANT ALL ON SEQUENCE public.tokens_id_seq TO anon;

GRANT ALL ON SEQUENCE public.tokens_id_seq TO authenticated;

GRANT ALL ON SEQUENCE public.tokens_id_seq TO postgres;

GRANT ALL ON SEQUENCE public.tokens_id_seq TO service_role;

GRANT ALL ON SEQUENCE public.tokens_id_seq TO supabase_admin;
CREATE SEQUENCE IF NOT EXISTS public.transactions_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.transactions_id_seq
    OWNER TO supabase_admin;

GRANT ALL ON SEQUENCE public.transactions_id_seq TO anon;

GRANT ALL ON SEQUENCE public.transactions_id_seq TO authenticated;

GRANT ALL ON SEQUENCE public.transactions_id_seq TO postgres;

GRANT ALL ON SEQUENCE public.transactions_id_seq TO service_role;

GRANT ALL ON SEQUENCE public.transactions_id_seq TO supabase_admin;


CREATE POLICY "Enable access to all users"
    ON public.tokens
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE POLICY "Enable insert for authenticated users only"
    ON public.profiles
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY "Only authenticated users can view profile - Temp"
    ON public.profiles
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));
CREATE POLICY "Users can update their own profiles."
    ON public.profiles
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = id));


CREATE POLICY "Only members can update a pool"
    ON public.pools
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() IN ( SELECT members.user_id
   FROM members
  WHERE (members.pool_id = pools.id))))
    WITH CHECK ((auth.uid() IN ( SELECT members.user_id
   FROM members
  WHERE (members.pool_id = pools.id))));

CREATE POLICY "Only members can view a pool"
    ON public.pools
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT members.user_id
   FROM members
  WHERE (members.pool_id = pools.id))));

CREATE POLICY "Restrict to pool members"
    ON public.accounts
    AS PERMISSIVE
    FOR ALL
    TO public
    USING ((pool_id IN ( SELECT get_pools_for_authenticated_user() AS get_pools_for_authenticated_user)))
    WITH CHECK ((pool_id IN ( SELECT get_pools_for_authenticated_user() AS get_pools_for_authenticated_user)));

CREATE POLICY "Restrict to pool members"
    ON public.categories
    AS PERMISSIVE
    FOR ALL
    TO public
    USING ((pool_id IN ( SELECT get_pools_for_authenticated_user() AS get_pools_for_authenticated_user)))
    WITH CHECK ((pool_id IN ( SELECT get_pools_for_authenticated_user() AS get_pools_for_authenticated_user)));

CREATE POLICY "Users can update members if they belong to the team"
    ON public.members
    AS PERMISSIVE
    FOR ALL
    TO public
    USING ((pool_id IN ( SELECT get_pools_for_authenticated_user() AS get_pools_for_authenticated_user)));

CREATE POLICY "Restrict to pool members"
    ON public.transactions
    AS PERMISSIVE
    FOR ALL
    TO public
    USING ((pool_id IN ( SELECT get_pools_for_authenticated_user() AS get_pools_for_authenticated_user)))
    WITH CHECK ((pool_id IN ( SELECT get_pools_for_authenticated_user() AS get_pools_for_authenticated_user)));

ALTER PUBLICATION supabase_realtime
    ADD TABLE public.transactions;
    
END;